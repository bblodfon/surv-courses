{
  "hash": "2ca55938af90dd2e8d499b2c77031a7e",
  "result": {
    "engine": "knitr",
    "markdown": "# Cox regression (high-dim) {-}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(survival)\nlibrary(glmnet)\nlibrary(tibble)\nlibrary(dplyr)\n```\n:::\n\n\n\n\nIn this exercise, we will use data for $115$ Norwegian women with breast cancer. For each of the women, we have gene expression measurements for $549$ «intrinsic genes» and information on the time to breast cancer death or censoring. (Source: Sørlie et al. Proc. Natl Acad. Sci. USA, 2003.)\n\nWe will use penalized Cox regression to investigate if the gene expressions have predictive power for survival and try to identify which genes are of importance.\n\nYou may read the data into R by the command:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrcancer=read.table(\"https://www.med.uio.no/imb/english/research/centres/ocbe/courses/imb9335/norw-breast-cancer.txt\")\n```\n:::\n\n\n\nBefore we analyse the data, we will define 10 folds that may be used in the cross-validation (to ensure – for pedagogical reasons - that all students get the same results). We do this by the commands\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(33575)\nind=sample(1:115,115)\nbrcancer=brcancer[ind,]\nfold=rep(1:10,length.out=115)\n```\n:::\n\n\n\nWe extract the (censored) survival times, the censoring/death statuses and the gene expressions by the commands\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntime=brcancer[,1]\nstatus=brcancer[,2]\ngeneexpr=as.matrix(brcancer[,-(1:2)])\n```\n:::\n\n\n\n\nCensoring problems with the folds?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(status == 0)/length(status)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6695652\n```\n\n\n:::\n\n```{.r .cell-code}\nstatus[fold == 5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 0 0 0 0 1 0 0 0 0 0 0\n```\n\n\n:::\n:::\n\n\n\n\nWe may then do a Cox-lasso regression with 10-fold cross-validation and plot the cross-validation curve by the commands (you need to load the survival and glmnet-packages)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncox.lasso=cv.glmnet(geneexpr,Surv(time,status),family=\"cox\",foldid=fold, standardize=FALSE)\nplot(cox.lasso)\n```\n\n::: {.cell-output-display}\n![](cox_regr_high_dim_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncox.lasso$lambda.min\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2902299\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(cox.lasso$lambda.min)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.237082\n```\n\n\n:::\n\n```{.r .cell-code}\nmin(cox.lasso$cvm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8.45301\n```\n\n\n:::\n:::\n\n\n\na) Perform the commands and interpret the cross-validation plot.\n\nWe may use the following commands to obtain a list of the genes that obtain an estimate that differ from zero (i.e. the selected genes):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoefficients=coef(cox.lasso, s=cox.lasso$lambda.min)\nactive.index=which(coefficients != 0)\nactive.coefficients=coefficients[active.index]\ncovarno=predict(cox.lasso, s=cox.lasso$lambda.min,type=\"nonzero\")\ncbind(covarno,active.coefficients)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  which active.coefficients\n1   356          -0.1720938\n```\n\n\n:::\n:::\n\n\n\n\nRepeat a number of times and see how the number of genes and the list of selected genes vary from splits to splits:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn = 25\ndl = list()\nfor(i in 1:n) {\n  # message(i)\n  cox.lasso = cv.glmnet(geneexpr,Surv(time,status),family=\"cox\",nfolds=10, standardize=FALSE)\n  coef_tbl = coef(cox.lasso, s = 'lambda.min') %>% # s = 'lambda.' different\n    as.matrix() %>%\n    as.data.frame() %>%\n    tibble::rownames_to_column(var = 'coef_name') %>%\n    dplyr::rename(value = `1`) %>%\n    filter(value != 0)\n  dl[[i]] = coef_tbl\n}\n\nres = dplyr::bind_rows(dl)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres %>% \n  group_by(coef_name) %>% \n  summarise(mean_coef = mean(value), ntimes=n()) %>%\n  arrange(desc(ntimes))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  coef_name mean_coef ntimes\n  <chr>         <dbl>  <int>\n1 V358       -0.174       25\n2 V23        -0.0384      18\n3 V200       -0.0193       6\n4 V271       -0.00971      3\n5 V233        0.00290      1\n```\n\n\n:::\n:::\n\n\n\n\nFinally, if time allows, you may try out the elastic net. You may fit a Cox elastic net (with alpha=0.5) for the original split into 10 folds by the command:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncox.net=cv.glmnet(geneexpr,Surv(time,status),family=\"cox\",alpha=0.5,foldid=fold, standardize=FALSE)\nplot(cox.net)\n```\n\n::: {.cell-output-display}\n![](cox_regr_high_dim_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\ne) Perform the command and see how many and which genes are selected.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}